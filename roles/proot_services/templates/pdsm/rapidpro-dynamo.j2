#!/bin/sh
# /usr/local/pdsm/services-available/rapidpro-dynamo
# PDSM service wrapper for RapidPro Dynalite
# FIXED: Uses direct binary execution via screen + explicit IPv4 binding

PDSM_COMMON="/usr/local/pdsm/lib/pdsm-common.sh"
[ -r "$PDSM_COMMON" ] && . "$PDSM_COMMON"

SERVICE_NAME="rapidpro-dynamo"
PIDFILE="/run/rapidpro/dynamo.pid"
LOGFILE="/var/log/rapidpro/dynamo.log"

mkdir -p /run/rapidpro
mkdir -p /var/log/rapidpro
mkdir -p {{ rapidpro_dir }}/dynamo
# Ensure extensive ownership fix
chown -R {{ iiab_admin_user }}:{{ iiab_admin_user }} /var/log/rapidpro /run/rapidpro {{ rapidpro_dir }}/dynamo 2>/dev/null || true

running() {
  # Check PID file first
  if [ -s "$PIDFILE" ]; then
    pid=$(cat "$PIDFILE")
    if kill -0 "$pid" 2>/dev/null; then
      return 0
    fi
  fi
  # Fallback to pgrep (and update pidfile)
  if pgrep -u "{{ iiab_admin_user }}" -f "dynalite" > "$PIDFILE"; then
    return 0
  fi
  return 1
}

start() {
  if running; then
    echo "[pdsm:$SERVICE_NAME] already running"
    return 0
  fi

  echo "[pdsm:$SERVICE_NAME] starting..."
  
  # Cleanup attempt
  pkill -u "{{ iiab_admin_user }}" -f "dynalite" >/dev/null 2>&1 || true
  rm -f "$PIDFILE"
  chown {{ iiab_admin_user }}:{{ iiab_admin_user }} "$LOGFILE" 2>/dev/null || true

  # Run via nohup as correct user (Bypass screen instability)
  if [ ! -x "{{ rapidpro_dir }}/start_dynamo.sh" ]; then
     echo "Launcher {{ rapidpro_dir }}/start_dynamo.sh not found" >&2
     return 1
  fi

  # Execute launcher in background with nohup
  # Logic: su -> nohup -> launcher. Redirects handled in launcher.
  # Use /bin/bash to ensure 'disown' and other builtins work
  su -s /bin/bash {{ iiab_admin_user }} -c "nohup {{ rapidpro_dir }}/start_dynamo.sh >/dev/null 2>&1 & disown"
  
  # Stabilization Loop
  for i in $(seq 1 10); do
      sleep 1
      if running; then
          echo "[pdsm:$SERVICE_NAME] started"
          return 0
      fi
  done
  
  echo "[pdsm:$SERVICE_NAME] failed to start" >&2
  return 1
}

stop() {
  if ! running; then
    echo "[pdsm:$SERVICE_NAME] already stopped"
    return 0
  fi

  echo "[pdsm:$SERVICE_NAME] stopping..."
  
  pid="$(cat "$PIDFILE" 2>/dev/null)"
  [ -n "$pid" ] && kill "$pid" 2>/dev/null
  
  for i in $(seq 1 5); do
      if ! running; then break; fi
      sleep 1
  done
  
  # Hard kill
  if running; then
      pkill -u "{{ iiab_admin_user }}" -f "dynalite" >/dev/null 2>&1 || true
  fi
  rm -f "$PIDFILE"
  
  echo "[pdsm:$SERVICE_NAME] stopped"
  return 0
}

status() {
  if running; then
    echo "[pdsm:$SERVICE_NAME] running"
    return 0
  fi
  echo "[pdsm:$SERVICE_NAME] not running"
  return 3
}

case "$1" in
  start|stop|restart|status) "$1" ;;
  *) echo "Usage: $0 {start|stop|restart|status}" >&2; exit 1 ;;
esac
